spinsys {
	channels	23Na
	nuclei		23Na
	quadrupole 1 2 1.5e6 0.6 0 0 0
#	quadrupole 1 2 1.0e6 0.0 0 0 0
	shift 1 0 0 0 0 0 0
#	quadrupole 2 2 1.5e6 0.6 0 0 0
#	shift 2 0 0 0 0 0 0
}

par {
	method			direct
	proton_frequency	400e6
	spin_rate		10e3
	sw			5e3
	variable np		512
	crystal_file		zcw986
	gamma_angles		10
	start_operator		Inz
	detect_operator		Inc
	verbose			1111
	variable rf		100000
	sw1			10e3
	ni			64
	variable phFirst	0
	variable phSecond	0
	variable phRec		0
}

proc pulseq {} {
	global par

	set tsw [expr 1.0e6/$par(sw)]
	set tsw1 [expr 1.0e6/$par(sw1)]
	set p90 [expr 0.25e6/$par(rf)]
#	matrix set 1 elements {{4 1} {1 4}}
	reset


    

    for {set i 0} {$i < $par(ni)} {incr i 2} {
	reset
	pulse 1 $par(rf) $par(phFirst)
	delay 40000
        delay [expr $i * $tsw1] 
#	filter 1
	pulse 1.5 $par(rf) $par(phSecond)
	#delay [expr $i * $tsw1 * 7.0 / 9.0] 
	for {set j 0} {$j < $par(np)} {incr j 1} {
		acq $par(phRec)
		delay $tsw
	}

	reset
	pulse 1 $par(rf) [expr $par(phFirst) + 30]
	delay 40000
        delay [expr $i * $tsw1] 
#	filter 1
	pulse 1.5 $par(rf) $par(phSecond)
	#delay [expr $i * $tsw1 * 7.0 / 9.0] 
	for {set j 0} {$j < $par(np)} {incr j 1} {
		acq $par(phRec)
		delay $tsw
	}

    }

	
}

proc main {} {
	global par
#3-quantum
	set phFirst [list 0	60	120	180	240	300]
	set phSecond [list 90	90	90	90	90	90]
	set phRec [list 0	180	0	180	0	180]


	set par(phFirst) [lindex $phFirst 0]
	set par(phSecond) [lindex $phSecond 0]
	set par(phRec) [lindex $phRec 0]
	set f [fsimpson]
	set steps [llength $phFirst]

	for {set i 1} {$i < $steps} {incr i 1} {
		set par(phFirst) [lindex $phFirst $i]
		set par(phSecond) [lindex $phSecond $i]
		set par(phRec) [lindex $phRec $i]
		set g [fsimpson]
		fadd $f $g
		puts "[expr $i + 1]/$steps"
	}
	fsave $f $par(name).fid
}

